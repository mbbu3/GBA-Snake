#include "game.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "images/startScreen.h"
#include "images/youLose.h"
#include "images/apple.h"
#include "images/youWin.h"
#include "images/gameScreen.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app.
typedef enum {
  START,
  PLAY,
  WIN,
  LOSE,
} GBAState;

int main(void) {
    /* TODO: */
    // Manipulate REG_DISPCNT here to set Mode 3. //

    unsigned short bgcolor = BLACK;

    REG_DISPCNT = MODE3 | BG2_ENABLE;

    DMA[3].src = &bgcolor;
    DMA[3].dst = videoBuffer;
    DMA[3].cnt = 240 * 160 | DMA_ON | DMA_SOURCE_FIXED;


    // Save current and previous state of button input.
    u32 previousButtons = BUTTONS;
    u32 currentButtons = BUTTONS;

    // Load initial game state
    GBAState state = START;

    Snake snake;
    snake.direction = 0;
    snake.size = 3;
    snake.bodyx[0] = 7;
    snake.bodyx[1] = 7;
    snake.bodyx[2] = 7;

    snake.bodyy[0] = 4;
    snake.bodyy[1] = 4;
    snake.bodyy[2] = 4;


    GameState gs;
    gs.snake = snake;
    gs.foodPosx = randint(0, 12);
    gs.foodPosy = randint(0, 7);
    if (gs.foodPosx == 7 && gs.foodPosy == 4) {
        gs.foodPosx++;
    }

    char score[] = "Size: ";
    int j = 0;

    while (1) {
        currentButtons = BUTTONS;  // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
        switch (state) {
            case START:
                waitForVBlank();
                drawFullScreenImageDMA(startScreen);
                if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
                    state = PLAY;
                }

                break;
            case PLAY:
                waitForVBlank();

                if (j == 0) {
                    drawFullScreenImageDMA(gameScreen);
                    drawCenteredString(144, 5, 64, 16, score, GREEN);
                }
                j = 1;
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                    j = 0;
                }

                if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons && gs.snake.direction != 2)) {
                    gs.snake.direction = 1;
                } else if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons) && gs.snake.direction != 1) {
                    gs.snake.direction = 2;
                } else if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons) && gs.snake.direction != 4) {
                    gs.snake.direction = 3;
                } else if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons) && gs.snake.direction != 3) {
                    gs.snake.direction = 4;
                }
                drawRectDMA(145, 53, 16, 16, BLACK);
                char strSize[4];
                sprintf(strSize, "%d", gs.snake.size);
                drawCenteredString(145, 53, 5, 16, strSize, GREEN);

                if (gs.snake.size == 104) {
                    state = WIN;
                }

                if (vBlankCounter % 7 == 0) {
                    int snakeCollision = 0;
                    snakeCollision = advanceSnake(&gs);
                    if (snakeCollision == -1) {
                        j = 0;
                        state = LOSE;
                    }
                    drawSnake(&gs);
                }
                drawApple(gs);

                break;
            case WIN:
                drawFullScreenImageDMA(youWin);
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                }
                break;
            case LOSE:
                drawFullScreenImageDMA(youLose);
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                }
                break;
        }

        previousButtons = currentButtons;  // Store the current state of the buttons
    }

    return 0;
}



int advanceSnake(GameState *gs) { //calculate where snake is, check collisions 
    GameState ps = *(gs);

    int newY = ps.snake.bodyy[0];
    int newX = ps.snake.bodyx[0];
    if (ps.snake.direction == 1) { //directions: {0: stat, 1: up, 2: down, 3: left, 4:right}
        newY = newY - 1;
    } else if (ps.snake.direction == 2) {
        newY = newY + 1;
    } else if (ps.snake.direction == 3) { 
        newX = newX - 1;
    } else if (ps.snake.direction == 4) {
        newX = newX + 1;
    }
    
    if (gs->snake.direction != 0) {
        int tempX = 0;
        int tempY = 0;
        int temp2X;
        int temp2Y;
        if (newX == ps.foodPosx && newY == ps.foodPosy) {
            gs->snake.size += 1;
            addNewApple(gs);
        }
        for (int i = 0; i < ps.snake.size; i++) {

            if (i == 0) {
                tempX = gs->snake.bodyx[0];
                tempY = gs->snake.bodyy[0];
                gs->snake.bodyx[0] = newX;
                gs->snake.bodyy[0] = newY;
            } else {
                if ((gs->snake.bodyx[i] == newX && gs->snake.bodyy[i] == newY) || 
                    newX < 0 || newY < 0 || newX > 12 || newY > 7) {
                    newX = 0;
                    newY = 0;
                    resetGame(gs);
                    return -1;
                }
                temp2X = gs->snake.bodyx[i];
                temp2Y = gs->snake.bodyy[i];
                gs->snake.bodyy[i] = tempY;
                gs->snake.bodyx[i] = tempX;
                gs->openSpots[tempY * 13 + tempX] = 1;
                tempX = temp2X;
                tempY = temp2Y;
            }
        }
        gs->openSpots[tempY * 13 + tempX] = 0;
        drawRectDMA(tempY * 16 + 16, tempX * 16 + 16, 16, 16, 0x6527);
        
    }
    return 1;
}

void drawSnake(GameState *gs) { //after advancement of the gs, redraw snake where it needs to be
    for (int i = 0; i < gs->snake.size; i++) {
        int x = (gs->snake.bodyx[i] * 16) + 16;
        int y = (gs->snake.bodyy[i] * 16) + 16;

        drawRectDMA(y, x, 16, 16, WHITE);
    }
}

void addNewApple(GameState *gs) { //after apple has been eaten, add new apple somewhere
    while (1) {
        int newX = randint(0,12);
        int newY = randint(0,7);
        if (gs->openSpots[newY * 13 + newX] == 0) {
            gs->foodPosx = newX;
            gs->foodPosy = newY;
            break;
        }

    }
}

void drawApple(GameState gs) {
    int x = (gs.foodPosx * 16) + 16;
    int y = (gs.foodPosy * 16) + 16;

    drawImageDMA(y, x, 16, 16, apple);

}

void resetGame(GameState *gs) {
    Snake snake;
    snake.direction = 0;
    snake.size = 3;
    snake.bodyx[0] = 7;
    snake.bodyx[1] = 7;
    snake.bodyx[2] = 7;

    snake.bodyy[0] = 4;
    snake.bodyy[1] = 4;
    snake.bodyy[2] = 4;


    gs->snake = snake;
    gs->foodPosx = randint(0, 12);
    gs->foodPosy = randint(0, 7);
    if (gs->foodPosx == 7 && gs->foodPosy == 4) {
        gs->foodPosx++;
    }
}